<?xml version="1.0"?>
<TeamMentor_Article Metadata_Hash="318829252" Content_Hash="-575646878">
  <Metadata>
    <Id>4f405937-de36-41e6-b327-e9146762c451</Id>
    <Library_Id>00000000-0000-0000-0000-000000000000</Library_Id>
    <Title>Input Is Validated for Length, Range, Format, And Type</Title>
    <Category>Input and Data Validation</Category>
    <Phase>Design</Phase>
    <Technology>ASP.NET 3.5</Technology>
    <Type>Checklist Item</Type>
    <DirectLink />
    <Tag />
    <Security_Demand />
    <Author />
    <Priority>1</Priority>
    <Status />
  </Metadata>
  <Content Sanitized="true" DataType="Html">
    <Data><![CDATA[<h1>What to Check For</h1><p>Input is validated on the server to ensure that it is in the expected format, based upon which contexts the input is used in, and encoded appropriately on output.</p><h1>Why</h1><p>An attacker passing malicious input can attempt SQL injection, cross-site scripting, and other injection attacks that aim to exploit your vulnerabilities in your application. Validating input helps to reduce these risks by ensuring that the input received matches the expected format. Input validation on its own is not sufficient; output encoding is also needed to fully prevent these attacks as well as to improve&nbsp;reliability. Validation should always be as strict as possible, to ensure that problems do not arise from input thought to be out-of-range but harmless. An allow-list approach should always be taken, never a block list, to ensure that this property is maintained.</p><h1>How to Check</h1><p>To check for this problem, use the following steps: </p><ol><li><p><strong>Ensure&nbsp;that numeric range constraints have been enforced. </strong>Check that the <em>RangeValidator</em> control has been used to constrain the numeric input to a specific range.</p></li><li><p><strong>Ensure that verification fields are validated. </strong>Check that the <em>CompareValidator</em> control has been used to ensure validity for verification fields. An example of a verification field is the password entry field, where the user is required to re-type the value and the two values are compared to validate them. </p></li><li><p><strong>Ensure that type constraints have been enforced on string fields. </strong>Check that the <em>RegularExpressionValidator</em> control has been used to validate string input. This validator performs a variety of checks on string input fields using regular expressions. </p></li><li><p><strong>Ensure that custom validation has been used to handle remaining input constraints. </strong>Check that the <em>CustomValidator</em> control has been used to validate input for constraints not handled by the built-in ASP.NET validators. When the <strong>CustomValidator</strong> control is used, it is important to check that input has been validated for length, range, format and type. Use this validator in cases where your application might require certain business logic constraints which cannot be enforced by the existing validators for example. </p></li><li><p><strong>Ensure that the Regex class is being used to validate other sources. </strong>If you need to validate input from sources other than form fields, such as query string parameters or cookies, check that the <strong>Regex</strong> class, within the <strong>System.Text.RegularExpressions</strong> namespace, is being used. </p></li></ol><h1>Problem Example</h1><p>Consider a very simple form for an online shopping cart. The cart component consists of two components:</p><ol><li><p>An HTML form that contains all of the fields that make up the order to be submitted for processing:</p><pre>&lt;html&gt;<br>  &lt;head&gt;<br>    &lt;title&gt;Widget shopping cart&lt;/title&gt;<br>  &lt;/head&gt;<br>  &lt;body&gt;<br>    &lt;H1&gt;Welcome to the most boring shopping cart on the web!&lt;/H1&gt;<br>     A widget's current price is $19.95 USD. Please use the following form to submit an order.<br>    &lt;form action="process_order.aspx" method="POST"&gt;<br>       &lt;p&gt;Please enter the number of widgets you would like to purchase:&lt;/p&gt;<br>      quantity:&lt;br/&gt;<br>      &lt;select name="WidgetQuantity"&gt;<br>        &lt;option value="1"&gt;1&lt;/option&gt;<br>        &lt;option value="2"&gt;2&lt;/option&gt;<br>        &lt;option value="3"&gt;3&lt;/option&gt;<br>        &lt;option value="4"&gt;4&lt;/option&gt;<br>      &lt;/select&gt;<br>      ...<br>      &lt;input type="submit" value="order"/&gt;<br>    &lt;/form&gt;<br>  &lt;/body&gt;<br>&lt;/html&gt;</pre></li><li><p>An ASP.NET page that processes the form submissions and performs the necessary steps to create the order.</p><pre>int dQuantity = Request("WidgetQuantity");<br>double dPrice = 19.95;<br>double dCost = dQuantity * dPrice;</pre></li></ol><p>This server side page is problematic because it lacks validation to ensure the quantity field is correct. The application works fine in the case where a user plays by the rules and submits the form as it is shown, because the quantity field ensures that the range constraints for the order quantity are always valid. However, if a clever user decides to construct their own form and submits a negative WidgetQuantity field, it causes a negative balance. Depending on what e-commerce system is used, this could result in a credit to the user's account. It also might subtract the negative balance from the company's inventory, which would carry significant ramifications and costs later on.</p><hr><p>Adapted from Microsoft patterns &amp; practices guidance. </p>]]></Data>
  </Content>
</TeamMentor_Article>